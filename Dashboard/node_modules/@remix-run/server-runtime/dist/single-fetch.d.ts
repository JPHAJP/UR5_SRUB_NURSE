import type { StaticHandler, unstable_DataStrategyFunction as DataStrategyFunction, UNSAFE_DataWithResponseInit as DataWithResponseInit } from "@remix-run/router";
import type { ServerBuild } from "./build";
import type { AppLoadContext } from "./data";
import { ServerMode } from "./mode";
import type { TypedDeferredData, TypedResponse } from "./responses";
import type { ActionFunctionArgs, LoaderFunctionArgs } from "./routeModules";
import type { SerializeFrom } from "./serialize";
export declare const SingleFetchRedirectSymbol: unique symbol;
type SingleFetchRedirectResult = {
    redirect: string;
    status: number;
    revalidate: boolean;
    reload: boolean;
    replace: boolean;
};
export type SingleFetchResult = {
    data: unknown;
} | {
    error: unknown;
} | SingleFetchRedirectResult;
export type SingleFetchResults = {
    [key: string]: SingleFetchResult;
    [SingleFetchRedirectSymbol]?: SingleFetchRedirectResult;
};
export declare const SINGLE_FETCH_REDIRECT_STATUS = 202;
export declare function getSingleFetchDataStrategy({ isActionDataRequest, loadRouteIds, }?: {
    isActionDataRequest?: boolean;
    loadRouteIds?: string[];
}): DataStrategyFunction;
export declare function singleFetchAction(build: ServerBuild, serverMode: ServerMode, staticHandler: StaticHandler, request: Request, handlerUrl: URL, loadContext: AppLoadContext, handleError: (err: unknown) => void): Promise<{
    result: SingleFetchResult;
    headers: Headers;
    status: number;
}>;
export declare function singleFetchLoaders(build: ServerBuild, serverMode: ServerMode, staticHandler: StaticHandler, request: Request, handlerUrl: URL, loadContext: AppLoadContext, handleError: (err: unknown) => void): Promise<{
    result: SingleFetchResults;
    headers: Headers;
    status: number;
}>;
export declare function getSingleFetchRedirect(status: number, headers: Headers, basename: string | undefined): SingleFetchRedirectResult;
export declare function encodeViaTurboStream(data: any, requestSignal: AbortSignal, streamTimeout: number | undefined, serverMode: ServerMode): ReadableStream<Uint8Array>;
export declare function data<D extends Serializable>(value: D, init?: number | ResponseInit): DataWithResponseInit<D>;
type MaybePromise<T> = T | Promise<T>;
type Serializable = undefined | null | boolean | string | symbol | number | Array<Serializable> | {
    [key: PropertyKey]: Serializable;
} | bigint | Date | URL | RegExp | Error | Map<Serializable, Serializable> | Set<Serializable> | Promise<Serializable>;
type DataFunctionReturnValue = Serializable | DataWithResponseInit<Serializable> | TypedDeferredData<Record<string, unknown>> | TypedResponse<Record<string, unknown>>;
export type Serialize<T extends Loader | Action> = Awaited<ReturnType<T>> extends TypedDeferredData<infer D> ? D : Awaited<ReturnType<T>> extends TypedResponse<Record<string, unknown>> ? SerializeFrom<T> : Awaited<ReturnType<T>> extends DataWithResponseInit<infer D> ? D : Awaited<ReturnType<T>>;
export type Loader = (args: LoaderFunctionArgs) => MaybePromise<DataFunctionReturnValue>;
export declare let defineLoader: <T extends Loader>(loader: T) => T;
export type Action = (args: ActionFunctionArgs) => MaybePromise<DataFunctionReturnValue>;
export declare let defineAction: <T extends Action>(action: T) => T;
export {};
